package com.the_qa_company.qendpoint.core.iterator.utils;

import java.io.IOException;
import java.util.Iterator;
import java.util.Objects;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;

/**
 * a utility class to create an iterator from the value returned by another
 * Thread
 *
 * @param <T> the iterator type
 * @author Antoine Willerval
 * @author HÃ¥vard M. Ottestad
 */

public class PipedCopyIteratorUnordered<T> extends PipedCopyIterator<T> {

	private static final int CORES = Runtime.getRuntime().availableProcessors();

	/**
	 * RuntimeException generated by the PipedCopyIterator
	 *
	 * @author Antoine Willerval
	 */
	public static class PipedIteratorException extends RuntimeException {
		public PipedIteratorException(String message, Throwable t) {
			super(message, t);
		}
	}

	/**
	 * Callback for the
	 * {@link #createOfCallback(PipedCopyIteratorUnordered.PipeCallBack)} method
	 *
	 * @param <T> the iterator type
	 * @author Antoine Willerval
	 */
	@FunctionalInterface
	public interface PipeCallBack<T> {
		/**
		 * method called from the new thread to generate the new data, at the
		 * end of the callback, the pipe is closed with or without exception
		 *
		 * @param pipe the pipe to fill
		 * @throws Exception any exception returned by the generator
		 */
		void createPipe(PipedCopyIteratorUnordered<T> pipe) throws Exception;
	}

	/**
	 * create a piped iterator from a callback runner, the call to the callback
	 * should be made in the callbackRunner
	 *
	 * @param callbackRunner the callback runner
	 * @param <T>            type of the iterator
	 * @return the iterator
	 */
	public static <T> PipedCopyIteratorUnordered<T> createOfCallback(PipeCallBack<T> callbackRunner) {
		PipedCopyIteratorUnordered<T> pipe = new PipedCopyIteratorUnordered<>();

		Thread thread = new Thread(() -> {
			try {
				callbackRunner.createPipe(pipe);
				pipe.closePipe();
			} catch (Throwable e) {
				pipe.closePipe(e);
			}
		}, "PipeIterator");
		thread.start();

		// close the thread at end
		pipe.attachThread(thread);

		return pipe;
	}

	private interface QueueObject<T> {
		boolean end();

		T get();
	}

	private class ElementQueueObject implements QueueObject<T> {
		private final T obj;

		private ElementQueueObject(T obj) {
			this.obj = obj;
		}

		@Override
		public boolean end() {
			return false;
		}

		@Override
		public T get() {
			return obj;
		}
	}

	private class EndQueueObject implements QueueObject<T> {
		@Override
		public boolean end() {
			return true;
		}

		@Override
		public T get() {
			throw new IllegalArgumentException();
		}
	}

	private final ArrayBlockingQueue<QueueObject<T>>[] queue = new ArrayBlockingQueue[CORES * 2];

	{
		for (int i = 0; i < queue.length; i++) {
			queue[i] = new ArrayBlockingQueue<>(16 * 1024);
		}
	}

	private final AtomicBoolean[] queueEnd = new AtomicBoolean[queue.length];

	{
		for (int i = 0; i < queueEnd.length; i++) {
			queueEnd[i] = new AtomicBoolean(false);
		}
	}

	private T next;
	private boolean end;
	private PipedIteratorException exception;

	private Thread thread;

	volatile ArrayBlockingQueue<QueueObject<T>> focusQueue;

	@Override
	public boolean hasNext() {
		if (end) {
			return false;
		}
		if (next != null) {
			return true;
		}

		QueueObject<T> obj;
		try {
			obj = useFocusQueue();

			if (obj == null) {
				obj = useThreadBasedQueue();
			}

		} catch (InterruptedException e) {
			throw new PipedIteratorException("Can't read pipe", e);
		}

		if (obj == null || obj.end()) {
			obj = checkAllQueues(obj);
		}

		if (obj.end()) {
			end = true;
			if (exception != null) {
				throw exception;
			}
			return false;
		}
		next = obj.get();
		return true;
	}

	private QueueObject<T> useThreadBasedQueue() throws InterruptedException {
		QueueObject<T> obj;
		int i = Thread.currentThread().hashCode();
		obj = queue[i % queue.length].poll();
		if (obj == null) {
			obj = iterateThroughAllQueues(obj);
		} else if (obj.end()) {
			setQueueEnd(queue[i % queue.length]);
		} else if (focusQueue == null) {
			focusQueue = queue[i % queue.length];
		}
		return obj;
	}

	private QueueObject<T> checkAllQueues(QueueObject<T> originalObj) {
		QueueObject<T> obj = null;
		boolean done;

		do {
			done = true;
			for (int i = 0; i < queue.length; i++) {
				if (queueEnd[i].get()) {
					continue;
				}
				done = false;
				ArrayBlockingQueue<QueueObject<T>> queueObjects = queue[i];
				obj = queueObjects.poll();
				if (obj == null) {
					try {
						Thread.sleep(10);
					} catch (InterruptedException e) {
						throw new RuntimeException(e);
					}
				} else if (!obj.end()) {
					return obj;
				} else {
					queueEnd[i].set(true);
				}
			}
		} while (!done);

		if (obj == null) {
			obj = originalObj;
		}

		return obj;
	}

	private QueueObject<T> iterateThroughAllQueues(QueueObject<T> obj) throws InterruptedException {
		while (obj == null) {
			for (int i = 0; i < queue.length; i++) {
				if (queueEnd[i].get()) {
					continue;
				}
				ArrayBlockingQueue<QueueObject<T>> queueObjects = queue[i];
				obj = queueObjects.poll();
				if (obj != null) {
					if (obj.end()) {
						queueEnd[i].set(true);
					} else if (focusQueue == null) {
						focusQueue = queueObjects;
					}
					return obj;
				}
			}
			Thread.sleep(10);
		}
		return obj;
	}

	private QueueObject<T> useFocusQueue() throws InterruptedException {
		QueueObject<T> obj;
		var focusQueue = this.focusQueue;
		if (focusQueue != null) {
			QueueObject<T> poll = focusQueue.poll();
			if (poll != null) {
				obj = poll;
				if (obj.end()) {
					setQueueEnd(focusQueue);
				}
			} else {
				obj = null;
				this.focusQueue = null;
			}
		} else {
			obj = null;
		}
		return obj;
	}

	private void setQueueEnd(ArrayBlockingQueue<QueueObject<T>> focusQueue) {
		for (int i = 0; i < queue.length; i++) {
			if (queue[i] == focusQueue) {
				queueEnd[i].set(true);
				break;
			}
		}
	}

	@Override
	public T next() {
		if (!hasNext()) {
			return null;
		}
		T next = this.next;
		this.next = null;
		return next;
	}

	public void closePipe() {
		closePipe(null);
	}

	public void closePipe(Throwable e) {
		if (e != null) {
			// clear the queue to force the exception
			for (ArrayBlockingQueue<QueueObject<T>> queueObjects : queue) {
				queueObjects.clear();
			}
			if (e instanceof PipedIteratorException) {
				this.exception = (PipedIteratorException) e;
			} else {
				this.exception = new PipedIteratorException("closing exception", e);
			}
		}
		try {
			for (ArrayBlockingQueue<QueueObject<T>> queueObjects : queue) {
				queueObjects.put(new EndQueueObject());
			}
		} catch (InterruptedException ee) {
			throw new PipedIteratorException("Can't close pipe", ee);
		}
	}

	/**
	 * map this iterator to another type
	 *
	 * @param mappingFunction the mapping function
	 * @param <E>             the future type
	 * @return mapped iterator
	 */
	public <E> Iterator<E> map(Function<T, E> mappingFunction) {
		return new MapIterator<>(this, mappingFunction);
	}

	/**
	 * map this iterator to another type
	 *
	 * @param mappingFunction the mapping function
	 * @param <E>             the future type
	 * @return mapped iterator
	 */
	public <E> Iterator<E> mapWithId(MapIterator.MapWithIdFunction<T, E> mappingFunction) {
		return new MapIterator<>(this, mappingFunction);
	}

	AtomicInteger index = new AtomicInteger(0);

	public void addElement(T node) {
		int i = Thread.currentThread().hashCode();
		int l = i % queue.length;
		try {
			boolean success = queue[l].offer(new ElementQueueObject(node));
			if (!success) {
				focusQueue = queue[l];
				while (!success) {
					for (ArrayBlockingQueue<QueueObject<T>> queueObjects : queue) {
						success = queueObjects.offer(new ElementQueueObject(node), 1, TimeUnit.MILLISECONDS);
						if (success) {
							break;
						}
					}
				}
			}

		} catch (InterruptedException ee) {
			throw new PipedIteratorException("Can't add element to pipe", ee);
		}
	}

	/**
	 * attach a thread to interrupt with this iterator
	 *
	 * @param thread the thread
	 */
	public void attachThread(Thread thread) {
		Objects.requireNonNull(thread, "thread can't be null!");
		if (this.thread != null && this.thread != thread) {
			throw new IllegalArgumentException("Thread already attached");
		}
		this.thread = thread;
	}

	/**
	 * Allow receiving again elements after an end node
	 */
	public void reset() {
		this.end = false;
	}

	@Override
	public void close() throws IOException {
		if (thread != null) {
			thread.interrupt();
		}
	}
}
